Route Distance Prediction on the San Francisco Road Network

This repository contains a CPS3440 course project on shortest-path distance prediction for the San Francisco (SF) road network.
The project compares classical algorithms (Dijkstra, A*), a multilayer perceptron (MLP), and a graph neural network (GNN).
It includes a complete workflow for data loading, training, evaluation, and visualization.

1. Project Overview

The goal of this project is to estimate shortest-path distances between pairs of nodes in a large real-world road network.

We explore both algorithmic and learning-based approaches:

Dijkstra and A* as exact baselines

MLP models using node coordinate features

A GNN model that leverages graph structure

Evaluation scripts and plotting utilities for analyzing performance

All experiments can be reproduced using the code and scripts in this repository.

2. Data and Repository Structure

Data for the SF road network is stored under data/sf/ (locally).
All result figures have been copied into the artifacts/ folder at the repository root.

Repository layout (simplified):

artifacts/

error_bins.png

expansion_bars.png

inference_times.png

mlp_error_coords.png

mlp_error_coords_diff.png

mlp_metrics.png

mlp_scatter_coords.png

mlp_scatter_coords_diff.png

data/sf/

graph.gpickle – road network graph (nodes and edges)

node_features.csv – node features (e.g., coordinates)

pairs.csv – source–target node pairs for training and evaluation

landmark_distances.npz – precomputed landmark-based distances

src/

data/ – data loading utilities

evaluation/ – evaluation functions and summary generation

models/ – definitions of MLP and GNN models

training/ – training loops for the different models

utils/ – helper functions

scripts/

run_experiments.py – main entry point for running experiments

generate_dataset.py – dataset generation or preprocessing (if needed)

analyze_error_bins.py – analysis of error by distance bins

expansion_analysis.py – node expansion statistics for search algorithms

plot_results.py – script for generating result figures

render_report.py – optional report or summary rendering

3. Environment Setup

Create and activate a virtual environment (Windows example):

python -m venv .venv
.\.venv\Scripts\activate


Install dependencies:

pip install -r requirements.txt


Make sure you run all commands from the project root with the virtual environment activated.

4. Running Experiments
4.1 Classical Baselines: Dijkstra and A*

Run exact routing baselines:

python scripts/run_experiments.py --data_dir data/sf --run_baselines


This evaluates Dijkstra and A* on the SF dataset and stores the results under data/sf/ and then exported plots into artifacts/.

4.2 Train the MLP Model
python scripts/run_experiments.py --data_dir data/sf --run_mlp


This trains the MLP model using node-based features such as raw coordinates (coords) and coordinate differences (coords_diff).

4.3 Train the GNN Model
python scripts/run_experiments.py --data_dir data/sf --run_gnn


This trains the GNN model on the SF graph and evaluates it on the same node pairs.

4.4 Generate Plots
python scripts/run_experiments.py --data_dir data/sf --gen_plots


This aggregates evaluation results and produces all figures used in the analysis.
The figures are then available in the artifacts/ directory.

5. Results

All the following figures are generated by the pipeline and stored in the artifacts/ folder in this repository.

5.1 MLP Metrics Across Feature Sets

This figure compares MLP performance using:

coords – raw node coordinates

coords_diff – coordinate differences between source and target

Using coords_diff leads to significantly lower prediction error.

5.2 Inference Time Comparison

This figure compares inference time for the following methods:

Dijkstra

A*

MLP

GNN

Classical algorithms (Dijkstra, A*) are much slower, while MLP and GNN achieve millisecond-level inference.

5.3 Error by Distance Bins

This figure shows prediction error (for example MAE) grouped by true distance ranges.
It illustrates how model performance changes with the length of the ground-truth path.

Main observations:

GNN error tends to increase for longer distances.

MLP with coords_diff features remains more stable across distance bins.

5.4 MLP Error vs True Distance (coords)

Error versus true distance for the MLP model when using raw coordinates as input features.
The plot shows substantial error and noticeable bias.

5.5 MLP Error vs True Distance (coords_diff)

Error versus true distance for the MLP model when using coordinate differences as input features.
Compared with raw coordinates, errors are smaller and less biased, showing that coords_diff is a better representation for this task.

5.6 Prediction Scatter Plot (coords)

Scatter plot of true distance versus predicted distance for the MLP model using raw coordinates.
The points deviate significantly from the diagonal, indicating that the model struggles with this feature choice.

5.7 Prediction Scatter Plot (coords_diff)

Scatter plot of true distance versus predicted distance for the MLP model using coordinate differences.
The points align much more closely with the diagonal, demonstrating a substantial improvement in prediction quality.

5.8 Node Expansions for Dijkstra vs A*

This figure compares the number of expanded nodes and frontier sizes for Dijkstra and A*.
A* consistently expands fewer nodes than Dijkstra, confirming its efficiency advantage on this road network.

6. Key Findings

A* is significantly faster than Dijkstra in both node expansions and runtime.

MLP with coords_diff provides the best trade-off between accuracy and computation cost.

The GNN model captures graph structure but can struggle on longer paths compared with a well-engineered MLP.

Feature engineering (e.g., using coordinate differences) has a strong impact on performance.

Once trained, MLP and GNN models offer very fast inference and scale well to large datasets.

A promising future direction is to combine ML predictions with classical search, for example using ML to approximate distances and A* to refine the final path.




